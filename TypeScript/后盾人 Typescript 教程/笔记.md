# TypeScript

* tsc 文件名  （编译 ts 文件）

* tsc -w  （监听）



### tsconfig.json 配置文件的使用

* 生成配置文件

  ```
  tsc --init
  ```

  ```
  {
     // 指定需要编译文件 否则默认当前目录下除了exclude之外的所有.ts, .d.ts,.tsx 文件
     "include": ["./test.ts"],
     // 指定需要编译文件 否则默认当前目录下除了exclude之外的所有.ts, .d.ts,.tsx 文件
     "files": ["./src/**/*"],
     // 不编译某些文件
     "exclude": ["test.ts"],
     "compilerOptions": {
         // 只编译修改过的文件,这个时候会生成tsconfig.tsbuildinfo,下次编译的时候会进行对比只编译修改过的文件 
         "incremental": true,
         // 指定 ECMAScript 目标版本: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', or 'ESNEXT'
         "target": "es5",
         // 指定使用模块: 'commonjs', 'amd', 'system', 'umd' or 'es2015'
         "module": "commonjs",
         /* 注意：如果未指定--lib，则会注入默认的librares列表。注入的默认库为：
         对于 --target ES5: DOM,ES5,ScriptHost
         对于 --target ES6: DOM,ES6,DOM.Iterable,ScriptHost
         TS 绝不会在您的代码中注入polyfill,所以需要你自己制定编译lib */
         "lib": ["es5", "dom", "ScriptHost", "es2015.promise"],
         // 允许编译JS
         "allowJs": true,
         /* 是否检测JS的语法,例如下面的语法编辑器会报错
         let name = 'paul';
         console.log(name.a.b) */
         "checkJs": true,
         // 指定 jsx 代码的生成: 'preserve', 'react-native', or 'react'
         "jsx": preserve,
         /* 如果设为true，编译每个ts文件之后会生成一个js文件和一个声明文件,
         declaration和allowJs不能同时设为true */
         "declaration": true
         // 值为true或false，指定是否为声明文件.d.ts生成map文件
         "declarationMap": true
         // 用来指定编译时是否生成.map文件
         "sourceMap": true,
         // 当module设置为 'amd' and 'system'的时候可以使用此命令,这样可以将ts文件打包到一个目录下
         "outFile":"./",
         //  outDir 编译后的文件存到到哪个目录下,默认是每一个ts文件的当前目录,,下面的配置就是把ts编译到build目录下
         "outDir": './build',
         // 下面单独介绍
         "rootDir": "./src",
         // 是否编译构建引用项目,很复杂后面介绍
         "composite": true,
         // 指定文件用来存储增量编译信息,默认是tsconfig.tsbuildinfo
         "tsBuildInfoFile": "./",
         // 编译的时候删除注释
         "removeComments": true,
         // 不生成编译文件，这个一般比较少用,这个build目录下将没有任何文件,但是会进行编译,有错误会抛出
         "noEmit": true,
         // 是否引入npm包tslib中的辅助函数,__extends等 
         "importHelpers": true,
         // 当target为'ES5' or 'ES3'时，为'for-of', spread, and destructuring'中的迭代器提供完全支持
         "downlevelIteration": true,
         // isolatedModules的值为true或false，指定是否将每个文件作为单独的模块，默认为true，它不可以和declaration同时设定
         // 不是很理解,将每一个文件作为单独模块
         "isolatedModules": true,
         /* Strict Type-Checking Options */
         // 严格模式将会打开下面的几个选项
         "strict": false, 
         /* 不允许变量或函数参数具有隐式any类型,例如
         function(name) {
             return name;
         } */
         "noImplicitAny": true,
         // null类型检测,const teacher: string = null;会报错
         "strictNullChecks": true,
         // 对函数参数进行严格逆变比较
         "strictFunctionTypes": true,
         // 严格检查bind call apply
         "strictBindCallApply": true,
         // 此规则将验证构造函数内部初始化前后已定义的属性。
         "strictPropertyInitialization": true,
         // 检测this是否隐式指定
         "noImplicitThis": true,
         // 使用js的严格模式,在每一个文件上部声明 use strict
         "alwaysStrict": true,
         /* Additional Checks */
         // 默认false,是否检测定义了但是没使用的变量
         "noUnusedLocals": true,
         // 用于检查是否有在函数体中没有使用的参数
         "noUnusedParameters": true,
         // 用于检查函数是否有返回值，设为true后，如果函数没有返回值则会提示
         "noImplicitReturns": true,
         // 用于检查switch中是否有case没有使用break跳出switch
         "noFallthroughCasesInSwitch": true,
         /* Module Resolution Options */
         // 用于选择模块解析策略，有'node'和'classic'两种类型
         "moduleResolution": "node",
         // 复杂的很 下面单独介绍这三个模块
         "baseUrl": './'
         "paths": {},                   
         "rootDirs": [],
         /* typeRoots用来指定声明文件或文件夹的路径列表，如果指定了此项，则只有在这里列出的声明文件才会被加载 */
         typeRoots: [],
         // types用来指定需要包含的模块，只有在这里列出的模块的声明文件才会被加载进来
         types:[],
         // 用来指定允许从没有默认导出的模块中默认导入 
         "allowSyntheticDefaultImports": true, 
         // 通过为导入内容创建命名空间，实现CommonJS和ES模块之间的互操作性
         "esModuleInterop": true ,
         // 不把符号链接解析为真实路径，具体可以了解下webpack和node.js的symlink相关知识
         "preserveSymlinks": true,
         "allowUmdGlobalAccess": true,
         
         // sourceRoot用于指定调试器应该找到TypeScript文件而不是源文件的位置，这个值会被写进.map文件里
         "sourceRoot": '',
         // mapRoot用于指定调试器找到映射文件而非生成文件的位置，指定map文件的根路径，该选项会影响.map文件中的sources属性
         "mapRoot",
         // inlineSourceMap指定是否将map文件内容和js文件编译在一个同一个js文件中，如果设为true,则map的内容会以//#soureMappingURL=开头，然后接base64字符串的形式插入在js文件底部
         "inlineSourceMap": true,
         // inlineSources用于指定是否进一步将ts文件的内容也包含到输出文件中
         "inlineSources": true,
         
         // experimentalDecorators用于指定是否启用实验性的装饰器特性
         "experimentalDecorators": true,
         
         // emitDecoratorMetadata用于指定是否为装上去提供元数据支持，关于元数据，也是ES6的新标准，可以通过Reflect提供的静态方法获取元数据，如果需要使用Reflect的一些方法，需要引用ES2015.Reflect这个库
         "emitDecoratorMetadata": true,
         // compileOnSave的值是true或false，如果设为true，在我们编辑了项目中的文件保存的时候，编辑器会根据tsconfig.json中的配置重新生成文件，不过这个要编辑器支持
         "compileOnSave": true,
         // 很复杂 下面介绍
         "references":[]",
     }
  }
  
  作者：chrisPaul101755
  链接：https://juejin.cn/post/6844904093568221191
  来源：稀土掘金
  著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
  ```

  ### unknown 与 any 区别

  ![image-20220623170638391](https://tva1.sinaimg.cn/large/e6c9d24egy1h3iafho23ej20lo0heabj.jpg)

* 使用断言解决 as

![image-20220623170727837](https://tva1.sinaimg.cn/large/e6c9d24egy1h3iagb1s33j20fq02ct8r.jpg)       

* 强行将 string 断言为 number

![image-20220623171016689](https://tva1.sinaimg.cn/large/e6c9d24egy1h3iaj8vls3j20l2026dfx.jpg)

### void 与 nover

* void 可能是 null 或者 undefined

* nover 就是什么都没有

### null 与 undefined

### type 定义类型

``` 
tyoe user = {
	name: syring
	age: number
}
```

### 函数结构定义

```ts
let fun: (a: number, b: number) => numer
fun = (x, y) => {
	return x + y
}
fun(1, 2)
```

### 元组

```ts
let tuple: [string, number, boolean] = ['1', 1, true]
```

### 枚举

```ts
enum SexType {
  BOY = '男',
  GIRL = '女',
  OTHER = '其他',
}

type User = {
  name: string
  age: number
  sex: SexType
}

const user: User = {
  name: 'John Doe',
  age: 32,
  sex: SexType.BOY,
}

console.log(user)

```

### 断言

* const 断言

  ```ts
  let a: '黄文杰' = '黄文杰' // 值类型
  
  let b = '黄文杰' as const // 将 string 类型转为值类型
  
  ```

* 数组转元组

  ![image-20220623190923582](https://tva1.sinaimg.cn/large/e6c9d24egy1h3idz7il1oj20j80aewf1.jpg)

  ![image-20220623191108800](https://tva1.sinaimg.cn/large/e6c9d24egy1h3ie10j0i8j20hi0aajry.jpg)

  `as const` 就是会转为元组或具体的值

  ```ts
  let a = 'hwj'
  let b = 111
  let arr = [a, b] as const
  // 另一种写法
  let newArr = <const>[a, b]
  let c = newArr[1]
  c = 1
  ```

  

* 对象

  ![image-20220623191416525](https://tva1.sinaimg.cn/large/e6c9d24egy1h3ie4arf68j20ry0deq3s.jpg)

* 结构中使用const

  ```ts
  function fun() {
    let a = 'hwj'
    let b = (x: number, y: number) => x + y
    return [a, b] as [typeof a, typeof b]
  }
  const [n, m] = fun() as [string, Function] // 返回值断言
  console.log((m as Function)(18, 2))
  // 另一种写法
  console.log((m as (x: number, y: number) => number)(18, 2))
  
  ```

  typeof 导出

  ```ts
  function fun() {
    let a = 'hwj'
    let b = (x: number, y: number) => x + y
    return [a, b] as [typeof a, typeof b]
  }
  const [n, m] = fun()
  console.log(m(18, 2))
  ```

  const

  ```ts
  function fun() {
    let a = 'hwj'
    let b = (x: number, y: number) => x + y
    return [a, b] as const
  }
  const [n, m] = fun()
  console.log(m(18, 2))
  ```

  断言，解构

  ```ts
  function fun() {
    let a = 'hwj'
    let b = (x: number, y: number) => x + y
    return [a, b] as const
  }
  const [n, m] = [...fun()]
  console.log(m(18, 2))
  ```

* 非空断言`!`

* dom 类型断言与断言处理

  ```ts
  let body = document.querySelector('body') as HTMLBodyElement
  let div = document.querySelector('.id') as HTMLDivElement
  console.log(div)
  ```

## 类与接口

* public 公开

* protected 只能在内部访问（受保护的）,继承也可使用

  ![image-20220624010534174](https://tva1.sinaimg.cn/large/e6c9d24egy1h3io9tolj8j20by05idfz.jpg)

* private 私有,如果父类定义了私有方法，子类是不能覆盖的。

* readonly 只读，不能修改

* constructor 

  ```ts
  class User {
    constructor(public name: string) {
      this.name = name
    }
  }
  ```

* static 静态属性

  ```ts
  class User {
    static age: number = 21
  }
  console.log(User.age)
  ```

​		![image-20220624010738392](https://tva1.sinaimg.cn/large/e6c9d24egy1h3ioby3n2qj20cg0a8t9b.jpg)	

* 单例模式（只能被实例化一次）

  ```js
  class Person {
    private static instance: Person | null = null
    private constructor() {}
    static make(): Person {
      if (Person.instance === null) {
        Person.instance = new Person()
        console.log('只创建一次实例')
      }
      return Person.instance
    }
  }
  ```

* get  set

  ```ts
  class Person {
    private _name: string
    constructor(name: string) {
      this._name = name
    }
    public get name(): string {
      return this._name
    }
    public set name(name: string) {
      this._name = name
    }
  }
  const person = new Person('黄文杰')
  person.name = '彭于晏'
  console.log(person.name)
  ```

* 抽象类 abstract

  * 抽象类必须使用 abstract

  * 不能在 constructor 上使用（"abstract" 修饰符仅可出现在类、方法或属性声明中）

  * 不能实例化

  * ```ts
    {
      // 抽象类必须使用 abstract
      abstract class Animation {
        constructor() {}
        abstract move(): void
        protected getPos(): number[] {
          return [100, 300]
        }
      }
    
      // 继承抽象类的类必须实现抽象类的抽象方法
      class Tank extends Animation {
        public move(): void {
          console.log('敌方坦克移动了')
        }
      }
    
      class Player extends Animation {
        public move(): void {
          console.log('玩家坦克移动了')
        }
      }
    }
    ```

  * abstract 与 interface(接口)

    * 不能在抽象类上使用

    * ```ts
      {
        interface AnimationInterface {
          name: string
          move(): void
        }
      
        // 抽象类必须使用 abstract
        abstract class Animation {
          abstract move(): void
          protected getPos(): number[] {
            return [100, 300]
          }
        }
      
        // 继承抽象类的类必须实现抽象类的抽象方法
        class Tank extends Animation {
          name: string = 'ass'
          public move(): void {
            console.log('敌方坦克移动了')
          }
        }
      
        class Player extends Animation implements AnimationInterface {
          name: string = 'aa'
          public move(): void {
            console.log('玩家坦克移动了')
          }
        }
        const play = new Player()
        console.log(play)
      }
      ```

      







## keyof

```ts
type Todo = {
  id: number;
  text: string;
  done: boolean;
}

const todo: Todo = {
  id: 1,
  text: "Learn TypeScript keyof",
  done: false
}

function prop<T extends object, K extends keyof T>(obj: T, key: K) {
  return obj[key];
}

const id = prop(todo, "id"); // const id: number
const text = prop(todo, "text"); // const text: string
const done = prop(todo, "done"); // const done: boolean
```

## 装饰器

* 类装饰器

  ```ts
  function fun(target: any) {
    console.log('Hello world')
  }
  @fun
  class Person {
    constructor() {
      console.log('Hello')
    }
    name: string = 'John'
  }
  const person = new Person()
  console.log(person.name)
  // Hello world
  // Hello
  // John
  ```

* 类装饰器的3种类型

  1. 普通装饰器（无法传参）

     ```ts
     function fun(target: any) {
       console.log('Hello world')
     }
     @fun
     class Person {
       constructor() {
         console.log('Hello')
       }
       name: string = 'John'
     }
     ```

     

  2. 装饰器工厂（可传参）

     ```ts
     function fun(test: number) {
       return function (target: any) {
         // 添加静态变量
         target.age = test
       }
     }
     @fun(1)
     class Person {
       constructor() {
         console.log('Hello')
       }
       name: string = 'John'
     }
     console.log(Person) // [class Person] { age: 1 }
     ```

     

  3. 重载构造函数













