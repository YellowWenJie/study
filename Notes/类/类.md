# 类

主要碰到这个问题，才决定复习类,不过这是 this 指向问题

```js
class Person {
  constructor(){
    this.a = '1'
  }
  getValue () {
    return this.a
  }

  againGetValue () {
    // 访问不到 this,因为作用域问题
    return ( function () {
      console.log(this.a)
    })()
  }

  onceAgainGetValue () {
    return ( () => {
      console.log(this.a)
    })()
  }
}

const a = new Person()
a.onceAgainGetValue()
```

```js
// // function Point (x, y) {
// //   this.x = x
// //   this.y = y
// // }
// // Point.prototype.toString = function () {
// //   return this.x + ',' + this.y
// // }
// // const point = new Point(1, 2)
// // console.log(point.toString())
// // const x = '1'
// // let obj = {
// //   a: '@',
// //   b: function () {
// //     console.log(this)
// //     return () => {
// //       console.log(this.a)
// //     }
// //   },
// //   c: () => {
// //     this.a = 1
// //     console.log(this)
   
// //   }
// // }

// // obj.b()()

// class Person {
//   constructor(){
//     this.a = '1'
//   }
//   getValue () {
//     return this.a
//   }

//   againGetValue () {
//     return ( function () {
//       console.log(this)
//     })()
//   }

//   onceAgainGetValue () {
//     return ( () => {
//       console.log(this)
//     })()
//   }
// }

// const a = new Person()
// a.againGetValue()


this.a = '1'

const b = function () {
  console.log(this.a)
  return () => {
    console.log(this.a)
  }
}
const c = () => {
  console.log(this.a)
}
function d () {
  console.log(this.a)
}
b()()

// const obj = {
//   a: 10,
//   b: function () {
//     console.log(this.a)
//     return () => {
//       console.log(this.a)
//     }
//   },
//   c: () => {
//     console.log(this.a)
//   }
// }

```

* Generator 方法

  ```js
  class Person {
    constructor (...args) {
      this.args = args
    }
  
    * [Symbol.iterator]() { 
      for (let arg of this.args) {
        yield arg
      }
    }
  }
  
  for (let i of new Person(1,2,3,4,5)) {
    console.log(i) // 1 2 3 4 5
  }
  ```

* static 定义静态属性/方法，不用 new 就能调用

* new target 能知道是否是被 new 出来的。

  子类继承后会返回之类，可以理解为父类 new target 只会判断父类